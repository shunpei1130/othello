{"ast":null,"code":"import { createElementVNode as _createElementVNode, toDisplayString as _toDisplayString, renderList as _renderList, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock, normalizeClass as _normalizeClass, createCommentVNode as _createCommentVNode, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\";\nconst _withScopeId = n => (_pushScopeId(\"data-v-57f89019\"), n = n(), _popScopeId(), n);\nconst _hoisted_1 = {\n  class: \"flex flex-col items-center justify-center min-h-screen bg-green-100\"\n};\nconst _hoisted_2 = /*#__PURE__*/_withScopeId(() => /*#__PURE__*/_createElementVNode(\"h1\", {\n  class: \"text-4xl font-bold mb-4\"\n}, \"オセロ\", -1));\nconst _hoisted_3 = {\n  class: \"mb-4\"\n};\nconst _hoisted_4 = {\n  class: \"mr-4\"\n};\nconst _hoisted_5 = {\n  class: \"board\"\n};\nconst _hoisted_6 = [\"onClick\", \"disabled\"];\nconst _hoisted_7 = {\n  class: \"mt-4\"\n};\nconst _hoisted_8 = {\n  key: 0,\n  class: \"text-xl font-bold\"\n};\nconst _hoisted_9 = {\n  key: 1,\n  class: \"text-xl\"\n};\nconst _hoisted_10 = {\n  class: \"mt-4 space-x-4\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, [_hoisted_2, _createElementVNode(\"div\", _hoisted_3, [_createElementVNode(\"span\", _hoisted_4, \"黒: \" + _toDisplayString($options.blackCount), 1), _createElementVNode(\"span\", null, \"白: \" + _toDisplayString($options.whiteCount), 1)]), _createElementVNode(\"div\", _hoisted_5, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList($data.board, (row, i) => {\n    return _openBlock(), _createElementBlock(_Fragment, null, [(_openBlock(true), _createElementBlock(_Fragment, null, _renderList(row, (cell, j) => {\n      return _openBlock(), _createElementBlock(\"button\", {\n        key: `${i}-${j}`,\n        class: _normalizeClass([{\n          'bg-green-500': cell === $data.EMPTY,\n          'bg-black': cell === $data.BLACK,\n          'bg-white': cell === $data.WHITE\n        }, \"cell\"]),\n        onClick: $event => $options.makeMove(i, j),\n        disabled: $data.gameOver || cell !== $data.EMPTY || $data.isCPUOpponent && $data.currentPlayer === $data.WHITE\n      }, null, 10, _hoisted_6);\n    }), 128))], 64);\n  }), 256))]), _createElementVNode(\"div\", _hoisted_7, [$data.gameOver ? (_openBlock(), _createElementBlock(\"p\", _hoisted_8, \" ゲーム終了! \" + _toDisplayString($options.blackCount > $options.whiteCount ? '黒' : $options.whiteCount > $options.blackCount ? '白' : '引き分け') + \"の勝ち! \", 1)) : (_openBlock(), _createElementBlock(\"p\", _hoisted_9, \"現在の手番: \" + _toDisplayString($data.currentPlayer === $data.BLACK ? '黒' : '白'), 1))]), _createElementVNode(\"div\", _hoisted_10, [_createElementVNode(\"button\", {\n    class: \"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\",\n    onClick: _cache[0] || (_cache[0] = (...args) => $options.resetGame && $options.resetGame(...args))\n  }, \"ゲームをリセット\"), _createElementVNode(\"button\", {\n    class: \"px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600\",\n    onClick: _cache[1] || (_cache[1] = (...args) => $options.toggleCPUOpponent && $options.toggleCPUOpponent(...args))\n  }, _toDisplayString($data.isCPUOpponent ? \"2人プレイに切り替え\" : \"CPUと対戦\"), 1)])]);\n}","map":{"version":3,"names":["class","_createElementVNode","key","_createElementBlock","_hoisted_1","_hoisted_2","_hoisted_3","_hoisted_4","_toDisplayString","$options","blackCount","whiteCount","_hoisted_5","_Fragment","_renderList","$data","board","row","i","cell","j","_normalizeClass","EMPTY","BLACK","WHITE","onClick","$event","makeMove","disabled","gameOver","isCPUOpponent","currentPlayer","_hoisted_6","_hoisted_7","_hoisted_8","_hoisted_9","_hoisted_10","_cache","args","resetGame","toggleCPUOpponent"],"sources":["C:\\Users\\shunp\\app\\new-othello-game\\src\\components\\OthelloGame.vue"],"sourcesContent":["<template>\r\n    <div class=\"flex flex-col items-center justify-center min-h-screen bg-green-100\">\r\n      <h1 class=\"text-4xl font-bold mb-4\">オセロ</h1>\r\n      <div class=\"mb-4\">\r\n        <span class=\"mr-4\">黒: {{ blackCount }}</span>\r\n        <span>白: {{ whiteCount }}</span>\r\n      </div>\r\n      <div class=\"board\">\r\n        <template v-for=\"(row, i) in board\">\r\n          <button\r\n            v-for=\"(cell, j) in row\"\r\n            :key=\"`${i}-${j}`\"\r\n            :class=\"{\r\n              'bg-green-500': cell === EMPTY,\r\n              'bg-black': cell === BLACK,\r\n              'bg-white': cell === WHITE\r\n            }\"\r\n            class=\"cell\"\r\n            @click=\"makeMove(i, j)\"\r\n            :disabled=\"gameOver || cell !== EMPTY || (isCPUOpponent && currentPlayer === WHITE)\"\r\n          ></button>\r\n        </template>\r\n      </div>\r\n      <div class=\"mt-4\">\r\n        <p v-if=\"gameOver\" class=\"text-xl font-bold\">\r\n          ゲーム終了! {{ blackCount > whiteCount ? '黒' : whiteCount > blackCount ? '白' : '引き分け' }}の勝ち!\r\n        </p>\r\n        <p v-else class=\"text-xl\">現在の手番: {{ currentPlayer === BLACK ? '黒' : '白' }}</p>\r\n      </div>\r\n      <div class=\"mt-4 space-x-4\">\r\n        <button class=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\" @click=\"resetGame\">ゲームをリセット</button>\r\n        <button class=\"px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600\" @click=\"toggleCPUOpponent\">\r\n          {{ isCPUOpponent ? \"2人プレイに切り替え\" : \"CPUと対戦\" }}\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </template>\r\n  \r\n  <script>\r\n  const BOARD_SIZE = 8;\r\n  const EMPTY = 0;\r\n  const BLACK = 1;\r\n  const WHITE = 2;\r\n  \r\n  const DIRECTIONS = [\r\n    [-1, -1], [-1, 0], [-1, 1],\r\n    [0, -1],           [0, 1],\r\n    [1, -1],  [1, 0],  [1, 1]\r\n  ];\r\n  \r\n  const initialBoard = () => {\r\n    const board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));\r\n    const mid = BOARD_SIZE / 2;\r\n    board[mid-1][mid-1] = WHITE;\r\n    board[mid-1][mid] = BLACK;\r\n    board[mid][mid-1] = BLACK;\r\n    board[mid][mid] = WHITE;\r\n    return board;\r\n  };\r\n  \r\n  const POSITION_WEIGHTS = [\r\n    [120, -20, 20,  5,  5, 20, -20, 120],\r\n    [-20, -40, -5, -5, -5, -5, -40, -20],\r\n    [ 20,  -5, 15,  3,  3, 15,  -5,  20],\r\n    [  5,  -5,  3,  3,  3,  3,  -5,   5],\r\n    [  5,  -5,  3,  3,  3,  3,  -5,   5],\r\n    [ 20,  -5, 15,  3,  3, 15,  -5,  20],\r\n    [-20, -40, -5, -5, -5, -5, -40, -20],\r\n    [120, -20, 20,  5,  5, 20, -20, 120]\r\n  ];\r\n  \r\n  export default {\r\n    data() {\r\n      return {\r\n        board: initialBoard(),\r\n        currentPlayer: BLACK,\r\n        gameOver: false,\r\n        isCPUOpponent: false,\r\n        timer: null,\r\n        BLACK: BLACK,\r\n        WHITE: WHITE,\r\n        EMPTY: EMPTY\r\n      };\r\n    },\r\n    computed: {\r\n      blackCount() {\r\n        return this.board.flat().filter(cell => cell === this.BLACK).length;\r\n      },\r\n      whiteCount() {\r\n        return this.board.flat().filter(cell => cell === this.WHITE).length;\r\n      }\r\n    },\r\n    watch: {\r\n      board: 'handleBoardChange',\r\n      currentPlayer: 'handleCurrentPlayerChange'\r\n    },\r\n    methods: {\r\n      handleBoardChange() {\r\n        if (this.isCPUOpponent && this.currentPlayer === this.WHITE && !this.gameOver) {\r\n          clearTimeout(this.timer);\r\n          this.timer = setTimeout(this.makeCPUMove, 1000);\r\n        }\r\n      },\r\n      handleCurrentPlayerChange() {\r\n        if (!this.canMove(this.board, this.currentPlayer)) {\r\n          if (!this.canMove(this.board, 3 - this.currentPlayer)) {\r\n            this.gameOver = true;\r\n          } else {\r\n            this.currentPlayer = 3 - this.currentPlayer;\r\n          }\r\n        }\r\n      },\r\n      canMove(board, player) {\r\n        for (let i = 0; i < BOARD_SIZE; i++) {\r\n          for (let j = 0; j < BOARD_SIZE; j++) {\r\n            if (this.isValidMove(board, i, j, player)) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      },\r\n      isValidMove(board, row, col, player) {\r\n        if (board[row][col] !== EMPTY) return false;\r\n  \r\n        for (const [dx, dy] of DIRECTIONS) {\r\n          let x = row + dx;\r\n          let y = col + dy;\r\n          let canFlip = false;\r\n  \r\n          while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\r\n            if (board[x][y] === EMPTY) break;\r\n            if (board[x][y] === player) {\r\n              if (canFlip) return true;\r\n              break;\r\n            }\r\n            canFlip = true;\r\n            x += dx;\r\n            y += dy;\r\n          }\r\n        }\r\n  \r\n        return false;\r\n      },\r\n      makeMove(row, col) {\r\n        if (this.gameOver || !this.isValidMove(this.board, row, col, this.currentPlayer)) return;\r\n  \r\n        const newBoard = this.board.map(row => [...row]);\r\n        newBoard[row][col] = this.currentPlayer;\r\n  \r\n        for (const [dx, dy] of DIRECTIONS) {\r\n          let x = row + dx;\r\n          let y = col + dy;\r\n          const toFlip = [];\r\n  \r\n          while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\r\n            if (newBoard[x][y] === EMPTY) break;\r\n            if (newBoard[x][y] === this.currentPlayer) {\r\n              for (const [fx, fy] of toFlip) {\r\n                newBoard[fx][fy] = this.currentPlayer;\r\n              }\r\n              break;\r\n            }\r\n            toFlip.push([x, y]);\r\n            x += dx;\r\n            y += dy;\r\n          }\r\n        }\r\n  \r\n        this.board = newBoard;\r\n        this.currentPlayer = 3 - this.currentPlayer;\r\n      },\r\n      evaluateBoard(board, player) {\r\n        let score = 0;\r\n        for (let i = 0; i < BOARD_SIZE; i++) {\r\n          for (let j = 0; j < BOARD_SIZE; j++) {\r\n            if (board[i][j] === player) {\r\n              score += POSITION_WEIGHTS[i][j];\r\n            } else if (board[i][j] === 3 - player) {\r\n              score -= POSITION_WEIGHTS[i][j];\r\n            }\r\n          }\r\n        }\r\n        return score;\r\n      },\r\n      getValidMoves(board, player) {\r\n        const validMoves = [];\r\n        for (let i = 0; i < BOARD_SIZE; i++) {\r\n          for (let j = 0; j < BOARD_SIZE; j++) {\r\n            if (this.isValidMove(board, i, j, player)) {\r\n              validMoves.push([i, j]);\r\n            }\r\n          }\r\n        }\r\n        return validMoves;\r\n      },\r\n      minimax(board, depth, maximizingPlayer, alpha, beta) {\r\n        if (depth === 0 || !this.canMove(board, this.BLACK) && !this.canMove(board, this.WHITE)) {\r\n          return this.evaluateBoard(board, this.WHITE);\r\n        }\r\n  \r\n        const player = maximizingPlayer ? this.WHITE : this.BLACK;\r\n        const validMoves = this.getValidMoves(board, player);\r\n  \r\n        if (maximizingPlayer) {\r\n          let maxEval = -Infinity;\r\n          for (const [row, col] of validMoves) {\r\n            const newBoard = board.map(row => [...row]);\r\n            this.makeMove(newBoard, row, col, player);\r\n            const evalScore = this.minimax(newBoard, depth - 1, false, alpha, beta);\r\n            maxEval = Math.max(maxEval, evalScore);\r\n            alpha = Math.max(alpha, evalScore);\r\n            if (beta <= alpha) break;\r\n          }\r\n          return maxEval;\r\n        } else {\r\n          let minEval = Infinity;\r\n          for (const [row, col] of validMoves) {\r\n            const newBoard = board.map(row => [...row]);\r\n            this.makeMove(newBoard, row, col, player);\r\n            const evalScore = this.minimax(newBoard, depth - 1, true, alpha, beta);\r\n            minEval = Math.min(minEval, evalScore);\r\n            beta = Math.min(beta, evalScore);\r\n            if (beta <= alpha) break;\r\n          }\r\n          return minEval;\r\n        }\r\n      },\r\n      makeCPUMove() {\r\n        const validMoves = this.getValidMoves(this.board, this.WHITE);\r\n        let bestScore = -Infinity;\r\n        let bestMove = null;\r\n  \r\n        for (const [row, col] of validMoves) {\r\n          const newBoard = this.board.map(row => [...row]);\r\n          newBoard[row][col] = this.WHITE;\r\n          const score = this.minimax(newBoard, 3, false, -Infinity, Infinity);\r\n          if (score > bestScore) {\r\n            bestScore = score;\r\n            bestMove = [row, col];\r\n          }\r\n        }\r\n  \r\n        if (bestMove) {\r\n          this.makeMove(bestMove[0], bestMove[1]);\r\n        }\r\n      },\r\n      resetGame() {\r\n        this.board = initialBoard();\r\n        this.currentPlayer = this.BLACK;\r\n        this.gameOver = false;\r\n      },\r\n      toggleCPUOpponent() {\r\n        this.isCPUOpponent = !this.isCPUOpponent;\r\n      },\r\n      getClass(cell) {\r\n        if (cell === EMPTY) return 'bg-green-500';\r\n        if (cell === this.BLACK) return 'bg-black';\r\n        return 'bg-white';\r\n      }\r\n    },\r\n    beforeUnmount() {\r\n      clearTimeout(this.timer);\r\n    }\r\n  };\r\n  </script>\r\n  \r\n  <style scoped>\r\n  .board {\r\n    display: grid;\r\n    grid-template-rows: repeat(8, 1fr);\r\n    grid-template-columns: repeat(8, 1fr);\r\n    gap: 2px;\r\n    background-color: #2d6a4f;\r\n    width: 400px;\r\n    height: 400px;\r\n    border: 4px solid #1b4332;\r\n  }\r\n  \r\n  .cell {\r\n    width: 100%;\r\n    height: 100%;\r\n    border-radius: 50%;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    border: 2px solid #1b4332;\r\n  }\r\n  \r\n  .bg-green-500 {\r\n    background-color: #4caf50;\r\n  }\r\n  \r\n  .bg-black {\r\n    background-color: black;\r\n  }\r\n  \r\n  .bg-white {\r\n    background-color: white;\r\n  }\r\n  </style>\r\n  "],"mappings":";;;EACSA,KAAK,EAAC;AAAqE;gEAC9EC,mBAAA,CAA4C;EAAxCD,KAAK,EAAC;AAAyB,GAAC,KAAG;;EAClCA,KAAK,EAAC;AAAM;;EACTA,KAAK,EAAC;AAAM;;EAGfA,KAAK,EAAC;AAAO;mBAPxB;;EAuBWA,KAAK,EAAC;AAAM;;EAvBvBE,GAAA;EAwB2BF,KAAK,EAAC;;;EAxBjCE,GAAA;EA2BkBF,KAAK,EAAC;;;EAEbA,KAAK,EAAC;AAAgB;;uBA5B7BG,mBAAA,CAkCM,OAlCNC,UAkCM,GAjCJC,UAA4C,EAC5CJ,mBAAA,CAGM,OAHNK,UAGM,GAFJL,mBAAA,CAA6C,QAA7CM,UAA6C,EAA1B,KAAG,GAAAC,gBAAA,CAAGC,QAAA,CAAAC,UAAU,OACnCT,mBAAA,CAAgC,cAA1B,KAAG,GAAAO,gBAAA,CAAGC,QAAA,CAAAE,UAAU,M,GAExBV,mBAAA,CAeM,OAfNW,UAeM,I,kBAdJT,mBAAA,CAaWU,SAAA,QArBnBC,WAAA,CAQqCC,KAAA,CAAAC,KAAK,EAR1C,CAQ0BC,GAAG,EAAEC,CAAC;yBARhCf,mBAAA,CAAAU,SAAA,U,kBASUV,mBAAA,CAWUU,SAAA,QApBpBC,WAAA,CAUgCG,GAAG,EAVnC,CAUoBE,IAAI,EAAEC,CAAC;2BADjBjB,mBAAA,CAWU;QATPD,GAAG,KAAKgB,CAAC,IAAIE,CAAC;QACdpB,KAAK,EAZlBqB,eAAA;0BAYqDF,IAAI,KAAKJ,KAAA,CAAAO,KAAK;sBAA6BH,IAAI,KAAKJ,KAAA,CAAAQ,KAAK;sBAA6BJ,IAAI,KAAKJ,KAAA,CAAAS;WAKlI,MAAM;QACXC,OAAK,EAAAC,MAAA,IAAEjB,QAAA,CAAAkB,QAAQ,CAACT,CAAC,EAAEE,CAAC;QACpBQ,QAAQ,EAAEb,KAAA,CAAAc,QAAQ,IAAIV,IAAI,KAAKJ,KAAA,CAAAO,KAAK,IAAKP,KAAA,CAAAe,aAAa,IAAIf,KAAA,CAAAgB,aAAa,KAAKhB,KAAA,CAAAS;mBAnBzFQ,UAAA;;eAuBM/B,mBAAA,CAKM,OALNgC,UAKM,GAJKlB,KAAA,CAAAc,QAAQ,I,cAAjB1B,mBAAA,CAEI,KAFJ+B,UAEI,EAFyC,UACpC,GAAA1B,gBAAA,CAAGC,QAAA,CAAAC,UAAU,GAAGD,QAAA,CAAAE,UAAU,SAASF,QAAA,CAAAE,UAAU,GAAGF,QAAA,CAAAC,UAAU,mBAAkB,OACrF,S,cACAP,mBAAA,CAA8E,KAA9EgC,UAA8E,EAApD,SAAO,GAAA3B,gBAAA,CAAGO,KAAA,CAAAgB,aAAa,KAAKhB,KAAA,CAAAQ,KAAK,mB,GAE7DtB,mBAAA,CAKM,OALNmC,WAKM,GAJJnC,mBAAA,CAA+G;IAAvGD,KAAK,EAAC,4DAA4D;IAAEyB,OAAK,EAAAY,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAE7B,QAAA,CAAA8B,SAAA,IAAA9B,QAAA,CAAA8B,SAAA,IAAAD,IAAA,CAAS;KAAE,UAAQ,GACtGrC,mBAAA,CAES;IAFDD,KAAK,EAAC,8DAA8D;IAAEyB,OAAK,EAAAY,MAAA,QAAAA,MAAA,UAAAC,IAAA,KAAE7B,QAAA,CAAA+B,iBAAA,IAAA/B,QAAA,CAAA+B,iBAAA,IAAAF,IAAA,CAAiB;sBACjGvB,KAAA,CAAAe,aAAa,gC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}