{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nconst BOARD_SIZE = 8;\nconst EMPTY = 0;\nconst BLACK = 1;\nconst WHITE = 2;\nconst DIRECTIONS = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\nconst initialBoard = () => {\n  const board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));\n  const mid = BOARD_SIZE / 2;\n  board[mid - 1][mid - 1] = WHITE;\n  board[mid - 1][mid] = BLACK;\n  board[mid][mid - 1] = BLACK;\n  board[mid][mid] = WHITE;\n  return board;\n};\nconst POSITION_WEIGHTS = [[120, -20, 20, 5, 5, 20, -20, 120], [-20, -40, -5, -5, -5, -5, -40, -20], [20, -5, 15, 3, 3, 15, -5, 20], [5, -5, 3, 3, 3, 3, -5, 5], [5, -5, 3, 3, 3, 3, -5, 5], [20, -5, 15, 3, 3, 15, -5, 20], [-20, -40, -5, -5, -5, -5, -40, -20], [120, -20, 20, 5, 5, 20, -20, 120]];\nexport default {\n  data() {\n    return {\n      board: initialBoard(),\n      currentPlayer: BLACK,\n      gameOver: false,\n      isCPUOpponent: false,\n      timer: null,\n      BLACK: BLACK,\n      WHITE: WHITE,\n      EMPTY: EMPTY\n    };\n  },\n  computed: {\n    blackCount() {\n      return this.board.flat().filter(cell => cell === this.BLACK).length;\n    },\n    whiteCount() {\n      return this.board.flat().filter(cell => cell === this.WHITE).length;\n    }\n  },\n  watch: {\n    board: 'handleBoardChange',\n    currentPlayer: 'handleCurrentPlayerChange'\n  },\n  methods: {\n    handleBoardChange() {\n      if (this.isCPUOpponent && this.currentPlayer === this.WHITE && !this.gameOver) {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(this.makeCPUMove, 1000);\n      }\n    },\n    handleCurrentPlayerChange() {\n      if (!this.canMove(this.board, this.currentPlayer)) {\n        if (!this.canMove(this.board, 3 - this.currentPlayer)) {\n          this.gameOver = true;\n        } else {\n          this.currentPlayer = 3 - this.currentPlayer;\n        }\n      }\n    },\n    canMove(board, player) {\n      for (let i = 0; i < BOARD_SIZE; i++) {\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          if (this.isValidMove(board, i, j, player)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n    isValidMove(board, row, col, player) {\n      if (board[row][col] !== EMPTY) return false;\n      for (const [dx, dy] of DIRECTIONS) {\n        let x = row + dx;\n        let y = col + dy;\n        let canFlip = false;\n        while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n          if (board[x][y] === EMPTY) break;\n          if (board[x][y] === player) {\n            if (canFlip) return true;\n            break;\n          }\n          canFlip = true;\n          x += dx;\n          y += dy;\n        }\n      }\n      return false;\n    },\n    makeMove(row, col) {\n      if (this.gameOver || !this.isValidMove(this.board, row, col, this.currentPlayer)) return;\n      const newBoard = this.board.map(row => [...row]);\n      newBoard[row][col] = this.currentPlayer;\n      for (const [dx, dy] of DIRECTIONS) {\n        let x = row + dx;\n        let y = col + dy;\n        const toFlip = [];\n        while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\n          if (newBoard[x][y] === EMPTY) break;\n          if (newBoard[x][y] === this.currentPlayer) {\n            for (const [fx, fy] of toFlip) {\n              newBoard[fx][fy] = this.currentPlayer;\n            }\n            break;\n          }\n          toFlip.push([x, y]);\n          x += dx;\n          y += dy;\n        }\n      }\n      this.board = newBoard;\n      this.currentPlayer = 3 - this.currentPlayer;\n    },\n    evaluateBoard(board, player) {\n      let score = 0;\n      for (let i = 0; i < BOARD_SIZE; i++) {\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          if (board[i][j] === player) {\n            score += POSITION_WEIGHTS[i][j];\n          } else if (board[i][j] === 3 - player) {\n            score -= POSITION_WEIGHTS[i][j];\n          }\n        }\n      }\n      return score;\n    },\n    getValidMoves(board, player) {\n      const validMoves = [];\n      for (let i = 0; i < BOARD_SIZE; i++) {\n        for (let j = 0; j < BOARD_SIZE; j++) {\n          if (this.isValidMove(board, i, j, player)) {\n            validMoves.push([i, j]);\n          }\n        }\n      }\n      return validMoves;\n    },\n    minimax(board, depth, maximizingPlayer, alpha, beta) {\n      if (depth === 0 || !this.canMove(board, this.BLACK) && !this.canMove(board, this.WHITE)) {\n        return this.evaluateBoard(board, this.WHITE);\n      }\n      const player = maximizingPlayer ? this.WHITE : this.BLACK;\n      const validMoves = this.getValidMoves(board, player);\n      if (maximizingPlayer) {\n        let maxEval = -Infinity;\n        for (const [row, col] of validMoves) {\n          const newBoard = board.map(row => [...row]);\n          this.makeMove(newBoard, row, col, player);\n          const evalScore = this.minimax(newBoard, depth - 1, false, alpha, beta);\n          maxEval = Math.max(maxEval, evalScore);\n          alpha = Math.max(alpha, evalScore);\n          if (beta <= alpha) break;\n        }\n        return maxEval;\n      } else {\n        let minEval = Infinity;\n        for (const [row, col] of validMoves) {\n          const newBoard = board.map(row => [...row]);\n          this.makeMove(newBoard, row, col, player);\n          const evalScore = this.minimax(newBoard, depth - 1, true, alpha, beta);\n          minEval = Math.min(minEval, evalScore);\n          beta = Math.min(beta, evalScore);\n          if (beta <= alpha) break;\n        }\n        return minEval;\n      }\n    },\n    makeCPUMove() {\n      const validMoves = this.getValidMoves(this.board, this.WHITE);\n      let bestScore = -Infinity;\n      let bestMove = null;\n      for (const [row, col] of validMoves) {\n        const newBoard = this.board.map(row => [...row]);\n        newBoard[row][col] = this.WHITE;\n        const score = this.minimax(newBoard, 3, false, -Infinity, Infinity);\n        if (score > bestScore) {\n          bestScore = score;\n          bestMove = [row, col];\n        }\n      }\n      if (bestMove) {\n        this.makeMove(bestMove[0], bestMove[1]);\n      }\n    },\n    resetGame() {\n      this.board = initialBoard();\n      this.currentPlayer = this.BLACK;\n      this.gameOver = false;\n    },\n    toggleCPUOpponent() {\n      this.isCPUOpponent = !this.isCPUOpponent;\n    },\n    getClass(cell) {\n      if (cell === EMPTY) return 'bg-green-500';\n      if (cell === this.BLACK) return 'bg-black';\n      return 'bg-white';\n    }\n  },\n  beforeUnmount() {\n    clearTimeout(this.timer);\n  }\n};","map":{"version":3,"names":["BOARD_SIZE","EMPTY","BLACK","WHITE","DIRECTIONS","initialBoard","board","Array","fill","map","mid","POSITION_WEIGHTS","data","currentPlayer","gameOver","isCPUOpponent","timer","computed","blackCount","flat","filter","cell","length","whiteCount","watch","methods","handleBoardChange","clearTimeout","setTimeout","makeCPUMove","handleCurrentPlayerChange","canMove","player","i","j","isValidMove","row","col","dx","dy","x","y","canFlip","makeMove","newBoard","toFlip","fx","fy","push","evaluateBoard","score","getValidMoves","validMoves","minimax","depth","maximizingPlayer","alpha","beta","maxEval","Infinity","evalScore","Math","max","minEval","min","bestScore","bestMove","resetGame","toggleCPUOpponent","getClass","beforeUnmount"],"sources":["C:\\Users\\shunp\\app\\new-othello-game\\src\\components\\OthelloGame.vue"],"sourcesContent":["<template>\r\n    <div class=\"flex flex-col items-center justify-center min-h-screen bg-green-100\">\r\n      <h1 class=\"text-4xl font-bold mb-4\">オセロ</h1>\r\n      <div class=\"mb-4\">\r\n        <span class=\"mr-4\">黒: {{ blackCount }}</span>\r\n        <span>白: {{ whiteCount }}</span>\r\n      </div>\r\n      <div class=\"board\">\r\n        <template v-for=\"(row, i) in board\">\r\n          <button\r\n            v-for=\"(cell, j) in row\"\r\n            :key=\"`${i}-${j}`\"\r\n            :class=\"{\r\n              'bg-green-500': cell === EMPTY,\r\n              'bg-black': cell === BLACK,\r\n              'bg-white': cell === WHITE\r\n            }\"\r\n            class=\"cell\"\r\n            @click=\"makeMove(i, j)\"\r\n            :disabled=\"gameOver || cell !== EMPTY || (isCPUOpponent && currentPlayer === WHITE)\"\r\n          ></button>\r\n        </template>\r\n      </div>\r\n      <div class=\"mt-4\">\r\n        <p v-if=\"gameOver\" class=\"text-xl font-bold\">\r\n          ゲーム終了! {{ blackCount > whiteCount ? '黒' : whiteCount > blackCount ? '白' : '引き分け' }}の勝ち!\r\n        </p>\r\n        <p v-else class=\"text-xl\">現在の手番: {{ currentPlayer === BLACK ? '黒' : '白' }}</p>\r\n      </div>\r\n      <div class=\"mt-4 space-x-4\">\r\n        <button class=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\" @click=\"resetGame\">ゲームをリセット</button>\r\n        <button class=\"px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600\" @click=\"toggleCPUOpponent\">\r\n          {{ isCPUOpponent ? \"2人プレイに切り替え\" : \"CPUと対戦\" }}\r\n        </button>\r\n      </div>\r\n    </div>\r\n  </template>\r\n  \r\n  <script>\r\n  const BOARD_SIZE = 8;\r\n  const EMPTY = 0;\r\n  const BLACK = 1;\r\n  const WHITE = 2;\r\n  \r\n  const DIRECTIONS = [\r\n    [-1, -1], [-1, 0], [-1, 1],\r\n    [0, -1],           [0, 1],\r\n    [1, -1],  [1, 0],  [1, 1]\r\n  ];\r\n  \r\n  const initialBoard = () => {\r\n    const board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));\r\n    const mid = BOARD_SIZE / 2;\r\n    board[mid-1][mid-1] = WHITE;\r\n    board[mid-1][mid] = BLACK;\r\n    board[mid][mid-1] = BLACK;\r\n    board[mid][mid] = WHITE;\r\n    return board;\r\n  };\r\n  \r\n  const POSITION_WEIGHTS = [\r\n    [120, -20, 20,  5,  5, 20, -20, 120],\r\n    [-20, -40, -5, -5, -5, -5, -40, -20],\r\n    [ 20,  -5, 15,  3,  3, 15,  -5,  20],\r\n    [  5,  -5,  3,  3,  3,  3,  -5,   5],\r\n    [  5,  -5,  3,  3,  3,  3,  -5,   5],\r\n    [ 20,  -5, 15,  3,  3, 15,  -5,  20],\r\n    [-20, -40, -5, -5, -5, -5, -40, -20],\r\n    [120, -20, 20,  5,  5, 20, -20, 120]\r\n  ];\r\n  \r\n  export default {\r\n    data() {\r\n      return {\r\n        board: initialBoard(),\r\n        currentPlayer: BLACK,\r\n        gameOver: false,\r\n        isCPUOpponent: false,\r\n        timer: null,\r\n        BLACK: BLACK,\r\n        WHITE: WHITE,\r\n        EMPTY: EMPTY\r\n      };\r\n    },\r\n    computed: {\r\n      blackCount() {\r\n        return this.board.flat().filter(cell => cell === this.BLACK).length;\r\n      },\r\n      whiteCount() {\r\n        return this.board.flat().filter(cell => cell === this.WHITE).length;\r\n      }\r\n    },\r\n    watch: {\r\n      board: 'handleBoardChange',\r\n      currentPlayer: 'handleCurrentPlayerChange'\r\n    },\r\n    methods: {\r\n      handleBoardChange() {\r\n        if (this.isCPUOpponent && this.currentPlayer === this.WHITE && !this.gameOver) {\r\n          clearTimeout(this.timer);\r\n          this.timer = setTimeout(this.makeCPUMove, 1000);\r\n        }\r\n      },\r\n      handleCurrentPlayerChange() {\r\n        if (!this.canMove(this.board, this.currentPlayer)) {\r\n          if (!this.canMove(this.board, 3 - this.currentPlayer)) {\r\n            this.gameOver = true;\r\n          } else {\r\n            this.currentPlayer = 3 - this.currentPlayer;\r\n          }\r\n        }\r\n      },\r\n      canMove(board, player) {\r\n        for (let i = 0; i < BOARD_SIZE; i++) {\r\n          for (let j = 0; j < BOARD_SIZE; j++) {\r\n            if (this.isValidMove(board, i, j, player)) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      },\r\n      isValidMove(board, row, col, player) {\r\n        if (board[row][col] !== EMPTY) return false;\r\n  \r\n        for (const [dx, dy] of DIRECTIONS) {\r\n          let x = row + dx;\r\n          let y = col + dy;\r\n          let canFlip = false;\r\n  \r\n          while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\r\n            if (board[x][y] === EMPTY) break;\r\n            if (board[x][y] === player) {\r\n              if (canFlip) return true;\r\n              break;\r\n            }\r\n            canFlip = true;\r\n            x += dx;\r\n            y += dy;\r\n          }\r\n        }\r\n  \r\n        return false;\r\n      },\r\n      makeMove(row, col) {\r\n        if (this.gameOver || !this.isValidMove(this.board, row, col, this.currentPlayer)) return;\r\n  \r\n        const newBoard = this.board.map(row => [...row]);\r\n        newBoard[row][col] = this.currentPlayer;\r\n  \r\n        for (const [dx, dy] of DIRECTIONS) {\r\n          let x = row + dx;\r\n          let y = col + dy;\r\n          const toFlip = [];\r\n  \r\n          while (x >= 0 && x < BOARD_SIZE && y >= 0 && y < BOARD_SIZE) {\r\n            if (newBoard[x][y] === EMPTY) break;\r\n            if (newBoard[x][y] === this.currentPlayer) {\r\n              for (const [fx, fy] of toFlip) {\r\n                newBoard[fx][fy] = this.currentPlayer;\r\n              }\r\n              break;\r\n            }\r\n            toFlip.push([x, y]);\r\n            x += dx;\r\n            y += dy;\r\n          }\r\n        }\r\n  \r\n        this.board = newBoard;\r\n        this.currentPlayer = 3 - this.currentPlayer;\r\n      },\r\n      evaluateBoard(board, player) {\r\n        let score = 0;\r\n        for (let i = 0; i < BOARD_SIZE; i++) {\r\n          for (let j = 0; j < BOARD_SIZE; j++) {\r\n            if (board[i][j] === player) {\r\n              score += POSITION_WEIGHTS[i][j];\r\n            } else if (board[i][j] === 3 - player) {\r\n              score -= POSITION_WEIGHTS[i][j];\r\n            }\r\n          }\r\n        }\r\n        return score;\r\n      },\r\n      getValidMoves(board, player) {\r\n        const validMoves = [];\r\n        for (let i = 0; i < BOARD_SIZE; i++) {\r\n          for (let j = 0; j < BOARD_SIZE; j++) {\r\n            if (this.isValidMove(board, i, j, player)) {\r\n              validMoves.push([i, j]);\r\n            }\r\n          }\r\n        }\r\n        return validMoves;\r\n      },\r\n      minimax(board, depth, maximizingPlayer, alpha, beta) {\r\n        if (depth === 0 || !this.canMove(board, this.BLACK) && !this.canMove(board, this.WHITE)) {\r\n          return this.evaluateBoard(board, this.WHITE);\r\n        }\r\n  \r\n        const player = maximizingPlayer ? this.WHITE : this.BLACK;\r\n        const validMoves = this.getValidMoves(board, player);\r\n  \r\n        if (maximizingPlayer) {\r\n          let maxEval = -Infinity;\r\n          for (const [row, col] of validMoves) {\r\n            const newBoard = board.map(row => [...row]);\r\n            this.makeMove(newBoard, row, col, player);\r\n            const evalScore = this.minimax(newBoard, depth - 1, false, alpha, beta);\r\n            maxEval = Math.max(maxEval, evalScore);\r\n            alpha = Math.max(alpha, evalScore);\r\n            if (beta <= alpha) break;\r\n          }\r\n          return maxEval;\r\n        } else {\r\n          let minEval = Infinity;\r\n          for (const [row, col] of validMoves) {\r\n            const newBoard = board.map(row => [...row]);\r\n            this.makeMove(newBoard, row, col, player);\r\n            const evalScore = this.minimax(newBoard, depth - 1, true, alpha, beta);\r\n            minEval = Math.min(minEval, evalScore);\r\n            beta = Math.min(beta, evalScore);\r\n            if (beta <= alpha) break;\r\n          }\r\n          return minEval;\r\n        }\r\n      },\r\n      makeCPUMove() {\r\n        const validMoves = this.getValidMoves(this.board, this.WHITE);\r\n        let bestScore = -Infinity;\r\n        let bestMove = null;\r\n  \r\n        for (const [row, col] of validMoves) {\r\n          const newBoard = this.board.map(row => [...row]);\r\n          newBoard[row][col] = this.WHITE;\r\n          const score = this.minimax(newBoard, 3, false, -Infinity, Infinity);\r\n          if (score > bestScore) {\r\n            bestScore = score;\r\n            bestMove = [row, col];\r\n          }\r\n        }\r\n  \r\n        if (bestMove) {\r\n          this.makeMove(bestMove[0], bestMove[1]);\r\n        }\r\n      },\r\n      resetGame() {\r\n        this.board = initialBoard();\r\n        this.currentPlayer = this.BLACK;\r\n        this.gameOver = false;\r\n      },\r\n      toggleCPUOpponent() {\r\n        this.isCPUOpponent = !this.isCPUOpponent;\r\n      },\r\n      getClass(cell) {\r\n        if (cell === EMPTY) return 'bg-green-500';\r\n        if (cell === this.BLACK) return 'bg-black';\r\n        return 'bg-white';\r\n      }\r\n    },\r\n    beforeUnmount() {\r\n      clearTimeout(this.timer);\r\n    }\r\n  };\r\n  </script>\r\n  \r\n  <style scoped>\r\n  .board {\r\n    display: grid;\r\n    grid-template-rows: repeat(8, 1fr);\r\n    grid-template-columns: repeat(8, 1fr);\r\n    gap: 2px;\r\n    background-color: #2d6a4f;\r\n    width: 400px;\r\n    height: 400px;\r\n    border: 4px solid #1b4332;\r\n  }\r\n  \r\n  .cell {\r\n    width: 100%;\r\n    height: 100%;\r\n    border-radius: 50%;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    border: 2px solid #1b4332;\r\n  }\r\n  \r\n  .bg-green-500 {\r\n    background-color: #4caf50;\r\n  }\r\n  \r\n  .bg-black {\r\n    background-color: black;\r\n  }\r\n  \r\n  .bg-white {\r\n    background-color: white;\r\n  }\r\n  </style>\r\n  "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}